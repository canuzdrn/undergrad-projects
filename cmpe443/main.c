/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

typedef struct
{
volatile uint32_t MODER;
volatile uint32_t OTYPER;
volatile uint32_t OSPEEDR;
volatile uint32_t PUPDR;
volatile uint32_t IDR;
volatile uint32_t ODR;
volatile uint32_t BSRR;
volatile uint32_t LCKR;
volatile uint32_t AFRL;
volatile uint32_t AFRH;
volatile uint32_t BRR;
uint32_t reserved;
volatile uint32_t SECCFGR;
}
GPIO_Type;

typedef struct
{
	volatile uint32_t CR1;
	volatile uint32_t CR2;
	uint32_t reserved0;
	volatile uint32_t DIER;
	volatile uint32_t SR;
	volatile uint32_t EGR;
	uint32_t reserved1;
	uint32_t reserved2;
	uint32_t reserved3;
	volatile uint32_t CNT;
	volatile uint32_t PSC;
	volatile uint32_t ARR;

}
TIM_6_7_Type;

typedef struct
{
volatile uint32_t CR1; 		// 0x00
volatile uint32_t CR2; 		// 0x04
uint32_t reserved0;			// 0x08
volatile uint32_t DIER;		// 0x0C
volatile uint32_t SR;		// 0x10
volatile uint32_t EGR;		// 0x14
volatile uint32_t CCMR1;	// 0x18
uint32_t reserved1;			// 0x1C
volatile uint32_t CCER;		// 0x20
volatile uint32_t CNT;		// 0x24
volatile uint32_t PSC;		// 0x28
volatile uint32_t ARR;		// 0x2C
uint32_t reserved2;			// 0x30
volatile uint32_t CCR1;		// 0x34
volatile uint32_t CCR2;		// 0x38
uint32_t reserved3;			// 0x3C
uint32_t reserved4;			// 0x40
volatile uint32_t BDTR;		// 0x44
}
TIM_15_Type;

typedef struct
{
volatile uint32_t CR1; 		// 0x00
volatile uint32_t CR2; 		// 0x04
uint32_t reserved0;			// 0x08
volatile uint32_t DIER;		// 0x0C
volatile uint32_t SR;		// 0x10
volatile uint32_t EGR;		// 0x14
volatile uint32_t CCMR1;	// 0x18
volatile uint32_t CCMR2;	// 0x1C
volatile uint32_t CCER;		// 0x20
volatile uint32_t CNT;		// 0x24
volatile uint32_t PSC;		// 0x28
volatile uint32_t ARR;		// 0x2C
uint32_t reserved2;			// 0x30
volatile uint32_t CCR1;		// 0x34
volatile uint32_t CCR2;		// 0x38
volatile uint32_t CCR3;		// 0x3C
volatile uint32_t CCR4;		// 0x40

}
TIM_2345_Type;

typedef struct
{
volatile uint32_t CR1; 		// 0x00
volatile uint32_t CR2; 		// 0x04
uint32_t reserved0;			// 0x08
volatile uint32_t DIER;		// 0x0C
volatile uint32_t SR;		// 0x10
volatile uint32_t EGR;		// 0x14
volatile uint32_t CCMR1;	// 0x18
uint32_t reserved1;			// 0x1C
volatile uint32_t CCER;		// 0x20
volatile uint32_t CNT;		// 0x24
volatile uint32_t PSC;		// 0x28
volatile uint32_t ARR;		// 0x2C
volatile uint32_t RCR;		// 0x30
volatile uint32_t CCR1;		// 0x34
uint32_t reserved2;			// 0x38
uint32_t reserved3;			// 0x3C
uint32_t reserved4;			// 0x40
volatile uint32_t BDTR;		// 0x44
volatile uint32_t DCR;		// 0x48
}
TIM_16_17_Type;


typedef struct {
	volatile uint32_t CR1;
	volatile uint32_t CR2;
	volatile uint32_t CR3;
	volatile uint32_t BRR;
	volatile uint32_t GTPR;
	volatile uint32_t RTOR;
	volatile uint32_t RQR;
	volatile uint32_t ISR;
	volatile uint32_t ICR;
	volatile uint32_t RDR;
	volatile uint32_t TDR;
	volatile uint32_t PRESC;
} USART_TypeDef;

#define GPIO_base 0x42020000
#define GPIOA ((GPIO_Type *) GPIO_base)
#define GPIOB ((GPIO_Type *) 0x42020400)
#define GPIOC ((GPIO_Type *) 0x42020800)
#define GPIOD ((GPIO_Type *)(GPIO_base + 0xC00UL))
#define GPIOE ((GPIO_Type *) 0x42021000)
#define GPIOG ((GPIO_Type *)(GPIO_base + 0x1800UL))

#define RCC_APB1ENR1 *((volatile uint32_t *) 0x40021058)
#define RCC_APB1ENR2 *((volatile uint32_t *) 0x4002105C)
#define RCC_APB2ENR *((volatile uint32_t *) 0x40021060)
#define RCC_AHB2ENR *((volatile uint32_t *) 0x4002104C)
#define RCC_CCIPR1 *((volatile uint32_t *) 0X40021088)

#define ISER1 *((volatile uint32_t *) 0xE000E104)
#define ISER2 *((volatile uint32_t *) 0xE000E108)
#define ICER2 *((volatile uint32_t *) 0XE000E188)

#define PWR_CR1	*((volatile uint32_t *) 0x40007000)
#define PWR_CR2	*((volatile uint32_t *) 0x40007004)

#define TIM2 ((TIM_2345_Type *)(0x40000000))
#define TIM3 ((TIM_2345_Type *)(0x40000400))
#define TIM4 ((TIM_2345_Type *)(0x40000800))
#define TIM5 ((TIM_2345_Type *)(0x40000C00))

#define TIM6 ((TIM_6_7_Type *)(0x40001000))
#define TIM7 ((TIM_6_7_Type *)(0x40001400))

#define TIM15 ((TIM_15_Type *)(0x40014000))
#define TIM16 ((TIM_16_17_Type *)(0x40014400))
#define TIM17 ((TIM_16_17_Type *)(0x40014800))

#define LPUART1	((USART_TypeDef *) 0x40008000)

#define ADC1_ISR *((volatile uint32_t *) 0x42028000) // 0.bit ready 2.bit eoc
#define ADC1_IER *((volatile uint32_t *) 0x42028004) // 2.bit eocie
#define ADC1_CR *((volatile uint32_t *) 0x42028008) // 0.bit enable 2.bit start 29.deepdwn 28 voltage 30 calibration
#define ADC1_CFGR *((volatile uint32_t *) 0x4202800C) // 13 cont
#define ADC1_SQR1 *((volatile uint32_t *) 0x42028030) // 6.bite channel
#define ADC1_DR *((volatile uint32_t *) 0x42028040)
#define ADC_CCR *((volatile uint32_t *) 0x42028308) // 16ya 3

#define TOFF 39990
#define TOFF2 38990
#define TON 9
#define HI 1
#define LO 0
#define maxsize 32

static uint16_t edgefirst_fullness, pulsewidth_fullness, fullness;
static double distance_fullness;
static uint16_t edgefirst_gyro, pulsewidth_gyro;
static double distance_gyro;

static uint16_t edgelast_fullness;
static uint16_t edgelast_servo;
static uint16_t edgelast_gyro;


uint8_t which_7s =0;
volatile uint8_t read_fullness =0;

uint8_t state_fullness=0;
static unsigned int ic_pin_fullness=LO;
uint8_t state_gyro=0;
static unsigned int ic_pin_gyro=LO;

static uint16_t edgefirst_servo, pulsewidth_servo;
static double distance_servo;
uint8_t state_servo=0;
static unsigned int ic_pin_servo=LO;

volatile uint8_t send_servo = 1;
volatile uint8_t open_lid_signal=0;
volatile uint8_t open_lock_signal=0;

// variables for ADC convention values
uint16_t flame_dig_value;
uint16_t sound_dig_value;
uint16_t gas_dig_value;
uint16_t index = 0;

// variables for to make buzzer on
uint16_t is_fall = 0;
uint16_t is_fire = 0;
uint16_t is_gas = 0;

double weight_data = 0;
double weight_data_temp = 0;
double weight_data_temp1 = 0;

uint16_t calculate_sound = 0;

// Alert variables for UART communication
uint32_t alert_full = 0;
uint32_t alert_weight = 0;
uint32_t alert_sound = 0;
uint32_t alert_fall = 0;
uint32_t alert_gas = 0;
uint32_t alert_fire = 0;
uint32_t alert_wet = 0;

void init_GPIOA()
{
    RCC_AHB2ENR |= 1<<0;
    GPIOA->MODER &= ~(3<<(1*2));  // alternate function for PA1 (ultrasonic trigger for fullness)
    GPIOA->MODER |=(2<<(1*2));
    GPIOA->AFRL &= ~(0xF << (1*4));
    GPIOA->AFRL |=1 << (1*4);

    GPIOA->MODER &= ~(3 <<(0*2)); // alternate function for PA0 (ultrasonic echo for fullness)
    GPIOA->MODER |= 2 <<(0*2);
    GPIOA->AFRL |= 1 <<(0*4);

    GPIOA->MODER &= ~(3<<(3*2)); // alternate function for PA3 (ultrasonic trigger for servo)
    GPIOA->MODER |=(2<<(3*2));
    GPIOA->AFRL &= ~(0xF << (3*4));
    GPIOA->AFRL |=14 << (3*4);

    GPIOA->MODER &= ~(3 <<(2*2)); // alternate function for PA2 (ultrasonic echo for servo)
    GPIOA->MODER |= 2 <<(2*2);
    GPIOA->AFRL |= 14 <<(2*4);


    GPIOA->MODER &= ~(3 << 12);	// alternate function for PA6 (servo OC)
    GPIOA->MODER |= (1 << 13);
    GPIOA->AFRL |= 14 <<(6*4);


    GPIOA->MODER &= ~(3 << 14);	// alternate function for PA7 (servo OC)
    GPIOA->MODER |= (1 << 15);
    GPIOA->AFRL |= 14 <<(7*4);

	GPIOA->MODER |= 1 << 18; // output for PA9 LED
	GPIOA->MODER &= ~(1 << 19);

}

void init_GPIOB(){
	RCC_AHB2ENR |= 1 << 1;

    GPIOB->MODER &= ~(3<<6); // output for PB3 7-segment enable
    GPIOB->MODER |=(1<<6);
    GPIOB->MODER &= ~(3<<8); // output for PB2 7-segment enable
    GPIOB->MODER |=(1<<8);

	 GPIOB->MODER &= ~(3<< 20); // alternate function for PB10 (ultrasonic echo for falling)
	 GPIOB->MODER |= (1 << 21);
	 GPIOB->AFRH &= ~(0xF << 8);
	 GPIOB->AFRH |= 1 << 8;

	 GPIOB->MODER &= ~(3 << 22); // alternate function for PB11 (ultrasonic trigger for falling)
	 GPIOB->MODER |= (1 << 23);
	 GPIOB->AFRH &= ~(0xF << 12);
	 GPIOB->AFRH |=	1 << 12;

	GPIOB->MODER |= 1 << 14; // PB7 LED
	GPIOB->MODER &= ~(1 << 15);

}

void init_GPIOC(void)
{
	RCC_AHB2ENR |= 1 << 2;
	GPIOC->MODER |= 0xFFFFFFFF;
	GPIOC->MODER |= 3 << 0; // analog mode for PC0 (flame sensor)
	GPIOC->MODER |= 3 << 2; // analog mode for PC1 (sound sensor)
	GPIOC->MODER |= 3 << 6; // analog mode for PC3 (gas sensor)

	GPIOC->MODER |= 1 << 14;
	GPIOC->MODER &= ~(1 << 15);

	GPIOC->MODER |= 1 << 12;
	GPIOC->MODER &= ~(1 << 13);


	GPIOC -> MODER &= ~(3 << 20); // PC_10 input
	GPIOC -> MODER &= ~(1 << 23); // PC_11 output

	GPIOC -> MODER &= ~(3 << 24);

}

void init_GPIOD() {
	RCC_AHB2ENR |= 1 << 3; //clock for GPIOD is enabled
	GPIOD->MODER &= ~(0xFFFF);	// make first 8 port output [0,7]
	GPIOD->MODER |= (0x5555);

	GPIOD -> MODER &= ~(1 << 19);
}

void init_GPIOE() {
	RCC_AHB2ENR |= 1 << 4; //clock for GPIOD is enabled
	GPIOE->MODER &= ~(0xFFFF);	// make first 8 port output [0,7]
	GPIOE->MODER |= (0x5555);
}

void init_GPIOG(){	// used for led

	RCC_AHB2ENR |= 1 << 6; //Enable Clock for GPIO, TX = PG7, RX = PG8


	GPIOG->MODER &= ~(1 << 1);  // make pg0 output
	GPIOG->MODER &= ~(1 << 3);	// make pg1 output

	//Change the functionality of the pin
	// PG7 AF8 = LPUART_TX
	GPIOG->MODER &= ~(3 << (7 * 2));
	GPIOG->MODER |= (2 << (7 * 2));
	GPIOG->AFRL |= (8 << (7 * 4));
	// PG8 AF8 = LPUART_RX
	GPIOG->MODER &= ~(3 << (8 * 2));
	GPIOG->MODER |= (2 << (8 * 2));
	GPIOG->AFRH |= (8 << (0 * 4));
}

void turn_on_green(){		// green on pg1
	GPIOG->ODR |= (1 << 0);
	GPIOG->ODR &= ~(1 << 1);
}

void turn_on_red(){			// red on pg0
	GPIOG->ODR |= (1 << 1);
	GPIOG->ODR &= ~(1 << 0);
}

void turn_off_led(){
	GPIOG->ODR |= (3 << 0);
}

void turn_on_blue(void){
	GPIOD -> ODR &= ~(1 << 9); // give high to PD9

}


void turn_off_blue(void){
	GPIOD -> ODR |= 1 << 9; // give low to PD9
}


void write_to_7s1(uint8_t number)
{
	static const uint8_t seven_segment[10]={0x3FU,0x06U,0x5BU,0x4FU,0x66U,0x6DU,0x7DU,0x07U,0x7FU,0x6FU};

	GPIOB->ODR &= ~(1<<3);
	GPIOB->ODR |= (1<<4);
	GPIOD->ODR |= (0xFFU); //clear the pin interface of 7S
	GPIOD->ODR &= ~seven_segment[number]; //write the digit to the pins
}

void write_to_7s2(uint8_t number)
{
	static const uint8_t seven_segment[10]={0x3FU,0x06U,0x5BU,0x4FU,0x66U,0x6DU,0x7DU,0x07U,0x7FU,0x6FU};
	GPIOB->ODR &= ~(1<<4);
	GPIOB->ODR |= (1<<3);
	GPIOD->ODR |= (0xFFU); //clear the pin interface of 7S
	GPIOD->ODR &= ~seven_segment[number]; //write the digit to the pins
}

void init_TIM6(){
	RCC_APB1ENR1 |= (1 << 4);

	TIM6->PSC = 3999;
	TIM6->CR1 &= ~(1 << 1);
	TIM6->DIER |= 1;
	ISER1 |= 1 << 17;
	TIM6->SR = 0;
	TIM6->CR1 |= 1;
	TIM6->ARR = 9;

}

void init_TIM7(){
	RCC_APB1ENR1 |= 1 << 5; //TIM6x_CLK is enabled, running at 4MHz
	TIM7->PSC = 999; //Set Prescaler
	TIM7->CR1 &= ~(1<<1); //OVF will generate an event
	TIM7->DIER |= 1; //NEW! enable UIF to generate an interrupt
	ISER1 |= 1 << 18;//NEW! enable global signaling for TIM6 interrupt
	TIM7 -> SR = 0;
	TIM7->CR1 |= 1; //TIM6_CNT is enabled (clocked
	TIM7 -> ARR = 200;
}

void init_TIM3(){
	RCC_APB1ENR1 |= 1 << 1; //TIM6x_CLK is enabled, running at 4MHz
	TIM3->PSC = 999; //Set Prescaler
	TIM3->CR1 &= ~(1<<1); //OVF will generate an event
	TIM3->DIER |= 1; //NEW! enable UIF to generate an interrupt
	ISER1 |= 1 << 14;//NEW! enable global signaling for TIM6 interrupt
	TIM3 -> SR = 0;
	TIM3->CR1 |= 1; //TIM6_CNT is enabled (clocked
	TIM3 -> ARR = 200;
}

void init_TIM4(){
	RCC_APB1ENR1 |= 1 << 2; //TIM6x_CLK is enabled, running at 4MHz
	TIM4->PSC = 999; //Set Prescaler
	TIM4->CR1 &= ~(1<<1); //OVF will generate an event
	TIM4->DIER |= 1; //NEW! enable UIF to generate an interrupt
	ISER1 |= 1 << 15;//NEW! enable global signaling for TIM6 interrupt
	TIM4 -> SR = 0;
	TIM4->CR1 |= 1; //TIM6_CNT is enabled (clocked
	TIM4 -> ARR = 200;
}

void TIM4_IRQHandler(void)
{

	TIM4 -> SR = 0;
	ADC1_CR |= 1 << 2;
}


void TIM3_IRQHandler(void)
{

	TIM3 -> SR = 0;
	if(which_7s){
		which_7s = 0;
	} else {
		which_7s = 1;
	}

}

void TIM6_IRQHandler(void){
	TIM6->SR = 0;

	if(send_servo == 0){
		send_servo = 1;
	}

	if(calculate_sound == 1) {
		calculate_sound = 0;
	}
}

void TIM7_IRQHandler(void)
{

	TIM7 -> SR = 0;
	if(read_fullness == 0){
		read_fullness = 1;
	}

}

void wait_TIM3(uint32_t milliseconds)
{
    TIM3->ARR = milliseconds;  //Set Delay
}

void wait_TIM6(uint32_t milliseconds)
{
    TIM6->ARR = milliseconds;  //Set Delay
}

void wait_TIM7(uint32_t milliseconds)
{
    TIM7->ARR = milliseconds;  //Set Delay
}

void init_TIM2()
{
	RCC_APB1ENR1 |= 1 << 0; //TIM15x_CLK is enabled, running at 4MHz
	TIM2->PSC = 3; //Set Prescaler
	TIM2->ARR = 39999;
	//TIM15->BDTR |= 1<<15;
	TIM2->CCMR1 &= ~(3<<8); // CC2 is configured as output
	TIM2->CCMR1 &= ~(1<<16); //OCREF: output compare mode
	//TIM15->BDTR |= 1<<15; //All OC and OCN outputs of TIM15 are enabled
	TIM2->CCMR1 |= 3<<12; //will toggle the value on PA3 at every match (CNT = CCR2)
	TIM2->CCER &= ~(1<<5); //set polarity to active high
	TIM2->CCER |= (1<<4); //OC2 signal is output on the corresponding output pin
	TIM2->SR=0; //clear all flags
	TIM2->CCR2 = TOFF; //The first interrupt will be generated some later
	TIM2->DIER |= 1<<2; //enable CC2 to generate an interrupt


	//Channel 1
	TIM2->CCMR1  |= 1; // CC1 is configured as input mapped to TI1

	TIM2->CCER |= (1<<3);
	TIM2->CCER |= (3); // both edges, CC1 enabled
	TIM2->SR=0; //clear all flags
	TIM2->DIER |= 1<<1; //enable CC1 to generate an interrupt


	// Channel 4
	TIM2->CCMR2 &= ~(3<<8);
	TIM2->CCMR2 &= ~(1<<16);
	TIM2->CCMR2 |= 3<<12;

	TIM2->CCER &= ~(1<<13);
	TIM2->CCER |= (1<<12);
	TIM2->SR=0; //clear all flags
	TIM2->CCR4 = TOFF; //The first interrupt will be generated some later
	TIM2->DIER |= 1<<4;

	//Channel 3
	TIM2->CCMR2  |= 1; // CC1 is configured as input mapped to TI1

	TIM2->CCER |= (1<<11);
	TIM2->CCER |= (3 << 8);
	TIM2->SR=0; //clear all flags
	TIM2->DIER |= 1<<3;


	ISER1 |= 1 << 13;//enable global signaling for TIM15 interrupt
	TIM2->CR1 |= 1; //TIM15_CNT is clocked

}


void TIM2_IRQHandler(void) //
{

		if((TIM2->SR & (1<<0))!= 0){

		}
		if((TIM2->SR & (1<<2))!= 0) //check for CCR2 interrupt
		{

			if(state_fullness == 0) //output is high
			{
				TIM2->CCR2 += TON;
				state_fullness = 1;
			}
			else //output is low
			{
				TIM2->CCR2 = TOFF2;
				state_fullness = 0;
			}
			TIM2->SR &= ~(1<<2);
		}

		if((TIM2->SR & (1<<1))!= 0) //check for CCR1 interrupt
		{

			 if(ic_pin_fullness==LO)//HI has come
			 {
				 ic_pin_fullness=HI;
				 edgefirst_fullness = TIM2->CCR1;
			 }
			 else //LO has come
			 {
				 ic_pin_fullness=LO;
				 edgelast_fullness = TIM2->CCR1;
				 if(edgelast_fullness > edgefirst_fullness){
					 pulsewidth_fullness= edgelast_fullness-edgefirst_fullness;
				 } else {
					 pulsewidth_fullness= edgefirst_fullness - edgelast_fullness;
				 }

				 distance_fullness = (pulsewidth_fullness * 0.0343 / 2) * 1.10 ;
				 if(read_fullness && (open_lid_signal == 0)){
					 if (distance_fullness > maxsize) {
						 fullness = 0;
					 } else if (distance_fullness < 7.2){
						 fullness = 99;
						 send_alert('f');
					 } else {
						 fullness = (int)(((maxsize - 7) - (distance_fullness-7)) *100)/ maxsize ;
						 alert_full = 0;
					 }

					 if (fullness < 5) {
						 fullness = 0;
					 }

					 read_fullness = 0;
					 TIM7->ARR = 1999;
				 }

			 }

			 TIM2->SR &= ~(1<<1);
		}

		if((TIM2->SR & (1<<4))!= 0) //check for CCR4 interrupt
		{

			if(state_gyro == 0) //output is high
			{
				TIM2->CCR4 += TON;
				state_gyro = 1;
			}
			else //output is low
			{
				TIM2->CCR4 = TOFF;
				state_gyro = 0;
			}
			TIM2->SR &= ~(1<<4);
		}

		if((TIM2->SR & (1<<3))!= 0) //check for CCR3 interrupt
		{

			 if(ic_pin_gyro==LO)//HI has come
			 {
				 ic_pin_gyro=HI;
				 edgefirst_gyro = TIM2->CCR3;
			 }
			 else //LO has come
			 {
				 ic_pin_gyro=LO;
				 pulsewidth_gyro= TIM2->CCR3-edgefirst_gyro;
				 distance_gyro = (pulsewidth_gyro * 0.0343 / 2) * 1.10 ;
				 if(distance_gyro > 10) {
					 is_fall = 1;
					 send_alert('d');
				 } else {
					 is_fall = 0;
					 alert_fall = 0;
				 }

			 }

			 TIM2->SR &= ~(1<<3);
		}
}

void init_TIM15()
{
	// common
	RCC_APB2ENR |= 1 << 16; //TIM15x_CLK is enabled, running at 4MHz
	TIM15->PSC = 3; // scale to microseconds
	TIM15->ARR = 39999;


	// channel 2 - output compare

	TIM15->CCMR1 &= ~(3<<8); // CC2 is configured as output
	TIM15->CCMR1 &= ~(1<<16); //OCREF: output compare mode

	TIM15->BDTR |= 1<<15; //All OC and OCN outputs of TIM15 are enabled

	TIM15->CCMR1 |= 3<<12; //will toggle the value on PA3 at every match (CNT = CCR2)
	TIM15->CCER &= ~(1<<5); //set polarity to active high
	TIM15->CCER |= (1<<4); //OC2 signal is output on the corresponding output pin
	TIM15->SR=0; //clear all flags
	TIM15->CCR2 = TOFF; //The first interrupt will be generated some later
	TIM15->DIER |= 1<<2; //enable CC2 to generate an interrupt

	//Channel 1 - input capture
	TIM15->CCMR1  |= 1; // CC1 is configured as input mapped to TI1
	TIM15->CCER |= (1<<3);
	TIM15->CCER |= (3); // both edges, CC1 enabled
	TIM15->SR=0; //clear all flags
	TIM15->DIER |= 1<<1; //enable CC1 to generate an interrupt
	ISER2 |= 1 << 5;//enable global signaling for TIM15 interrupt
	TIM15->CR1 |= 1; //TIM15_CNT is clocked

}

void TIM15_IRQHandler(void) // ISR for TIM15
{
		if((TIM15->SR & (1<<2))!= 0) //check for CCR2 interrupt
		{

			if(state_servo == 0) //output is high (due to toggle output becomes 1 here , no need to write explicitly)
			{
				TIM15->CCR2 += TON;
				state_servo = 1;
			}
			else //output is low
			{
				TIM15->CCR2 = TOFF;
				state_servo = 0;
			}
			TIM15->SR &= ~(1<<2);
		}

		if((TIM15->SR & (1<<1))!= 0) //check for CCR1 interrupt
		{

			 if(ic_pin_servo==LO)//HI has come
			 {
				 ic_pin_servo=HI;
				 edgefirst_servo = TIM15->CCR1;
			 }
			 else //LO has come
			 {
				 edgelast_servo = TIM15->CCR1;
				 ic_pin_servo=LO;

				 //if(edgelast_servo > edgefirst_servo){
				//	 pulsewidth_servo= edgelast_servo - edgefirst_servo;
				 //} else {
				//	 pulsewidth_servo= edgefirst_servo - edgelast_servo;
				 //}

				 pulsewidth_servo = TIM15->CCR1 - edgefirst_servo;
				 distance_servo = (pulsewidth_servo * 0.0343 / 2);
				 if(send_servo == 1){
					 if(distance_servo <= 8){
						 send_servo = 0;
					 	open_lid_signal = 1;
					 	calculate_sound = 1;
					 }
					 else{
					 	open_lid_signal = 0;
					 }
				 }
			 }
			 TIM15->SR &= ~(1<<1);
		}
}

void init_TIM16()
{
	// common
	RCC_APB2ENR |= 1 << 17; //TIM16x_CLK is enabled, running at 4MHz
	TIM16->PSC = 3; // scale to microseconds
	TIM16->ARR = 19999;


	// channel 2 - output compare

	TIM16->CCMR1 &= ~(3<<0);  // CC1S is configured as output
	TIM16->CCMR1 &= ~(1<<16); //OCREF: output compare mode
	TIM16->BDTR |= 1<<15;
	TIM16->CCMR1 &= ~(1<<4);
	TIM16->CCMR1 |= 3<<5;    // pwm mode

	TIM16->CCER &= ~(1<<1); //set polarity to active high
	TIM16->CCER |= (1<<0); //OC1 signal is output on the corresponding output pin

	TIM16->CCR1 = 499;

	TIM16->DIER |= 1<<1; //enable CC1 to generate an interrupt
	ISER2 |= 1 << 6;//enable global signaling for TIM16 interrupt
	TIM16->CR1 |= 1; //TIM16_CNT is clocked

	TIM16->SR=0; //clear all flags
}

void TIM16_IRQHandler(void) // ISR for TIM16
{
		if((TIM16->SR & (1<<1))!= 0) //check for CCR1 interrupt
		{
			// TIM16->CCR1 = 2199;		// 499 -90, 999 -45, 1499 0, 2499 : 90
			if(open_lid_signal != 0){
				turn_on_green();
				TIM16->CCR1 = 1499;
				TIM6->ARR = 2999;
			}

			else{
				turn_on_red();
				TIM16->CCR1 = 499;
			}

			TIM16->SR &= ~(1<<1);
		}
}

void init_ADC(void){
	ISER1 |= 1 << 5;
	RCC_AHB2ENR |= 1 << 13;
	ADC1_CR &= ~(1 << 29);
	ADC1_CR |= 1 << 28;
	RCC_CCIPR1 |= 3 << 28;
	ADC1_IER |= 1 << 2;
	ADC1_SQR1 &= ~(0x0FFFU);
	ADC1_SQR1 |= 1 << 1;
	ADC1_SQR1 |= 1 << 6;
	ADC1_SQR1 |= 2 << 12;
	ADC1_SQR1 |= 4 << 18;
	ADC_CCR |= 3 << 16;
	ADC1_CR |= 1 << 31;
	while((ADC1_CR & (1 << 31)) != 0);
	ADC1_CR |= 1;
	while((ADC1_ISR & 1) == 0);
}

void ADC1_2_IRQHandler(void)
{

	if((ADC1_ISR & (1 << 2)) != 0)
	{
		if(index == 0)
		{
			flame_dig_value = ADC1_DR;
			index = 1;
		}
		else if (index == 1)
		{
			sound_dig_value = ADC1_DR;
			index = 2;
		}
		else if (index == 2)
		{
			gas_dig_value = ADC1_DR;
			index = 0;
		}
	}
	ADC1_ISR &= ~(1 << 2);
	TIM4->ARR = 999;
}

void init_LPUART(void){
	RCC_APB1ENR1 |= 1 << 28; //Enable Clock for Power Interface
	PWR_CR1 |= 1 << 14; //Change the regulator mode to Low-power mode
	PWR_CR2 |= 1 << 9; //Make VDDIO2 valid
	RCC_CCIPR1 &= ~(3 << 10); //Change the clock source of Low-power UART to SYSCLK
	RCC_CCIPR1 |= (1 << 10); //Change the clock source of Low-power UART to SYSCLK
	RCC_APB1ENR2 |= 1 << 0; //Enable Clock for Low-power UART
	LPUART1->BRR |= 106667; // for baud rate 9600, set BRR to 106667 , 0x22B9

	ISER2 |= (1 << 2); // enable interrupt
	LPUART1->CR1 |= 1 << 5; // enable interrupt for receive
	LPUART1->CR1 |= 1 << 29; // Enable FIFO mode for UART
	LPUART1->CR1 |= 1 << 0; // Enable LPUART
	LPUART1->CR1 |= 1 << 2; // Enable Receiver
	LPUART1->CR1 |= 1 << 3; // Enable Transmitter
}

void LPUART1_IRQHandler() {

	uint8_t inp = LPUART1->RDR;
	uint32_t first;
	uint32_t sec;

	switch (inp) {
	case 'f':
		 first = fullness / 10;
		 sec = fullness % 10;
		LPUART1->TDR = first + 48;
		LPUART1->TDR = sec + 48;
		LPUART1->TDR = 37;
		LPUART1->TDR = 0x0A;
		LPUART1->TDR = 0x0D;
		break;
	case 'w':
		int weight_temp = (int) weight_data;

		 first = (weight_temp / 1000)%10;
		 sec = (weight_temp / 100)%10;
		uint32_t third = (weight_temp / 10)%10;
		uint32_t fourth = (weight_temp)%10;
		LPUART1->TDR = first + 48;
		LPUART1->TDR = sec + 48;
		LPUART1->TDR = third + 48;
		LPUART1->TDR = fourth + 48;
		LPUART1->TDR = 'g';
		LPUART1->TDR = 0x0A;
		LPUART1->TDR = 0x0D;
		break;
	}
}

void send_alert(char c) {
	switch (c) {
	case 'f':
		if (alert_full == 0) {
			LPUART1->TDR = 'F';
			LPUART1->TDR = 'U';
			LPUART1->TDR = 'L';
			LPUART1->TDR = 'L';
			alert_full = 1;
			LPUART1->TDR = 0x0A;
			LPUART1->TDR = 0x0D;
		}
		break;
	case 'w':
		if (alert_weight == 0) {
			LPUART1->TDR = 'H';
			LPUART1->TDR = 'E';
			LPUART1->TDR = 'A';
			LPUART1->TDR = 'V';
			LPUART1->TDR = 'Y';
			alert_weight = 1;
			LPUART1->TDR = 0x0A;
			LPUART1->TDR = 0x0D;
		}
		break;
	case 'a':
		if (alert_fire == 0) {
			LPUART1->TDR = 'F';
			LPUART1->TDR = 'I';
			LPUART1->TDR = 'R';
			LPUART1->TDR = 'E';
			alert_fire = 1;
			LPUART1->TDR = 0x0A;
			LPUART1->TDR = 0x0D;
		}
		break;
	case 'g':
		if (alert_gas == 0) {
			LPUART1->TDR = 'G';
			LPUART1->TDR = 'A';
			LPUART1->TDR = 'S';
			alert_gas = 1;
			LPUART1->TDR = 0x0A;
			LPUART1->TDR = 0x0D;
		}
		break;
	case 's':
		if (alert_sound == 0 ) {
			LPUART1->TDR = 'S';
			LPUART1->TDR = 'O';
			LPUART1->TDR = 'U';
			LPUART1->TDR = 'N';
			LPUART1->TDR = 'D';
			alert_sound = 1;
			LPUART1->TDR = 0x0A;
			LPUART1->TDR = 0x0D;
		}
		break;
	case 'd':
		if (alert_fall == 0) {
			LPUART1->TDR = 'F';
			LPUART1->TDR = 'A';
			LPUART1->TDR = 'L';
			LPUART1->TDR = 'L';
			alert_fall = 1;
			LPUART1->TDR = 0x0A;
			LPUART1->TDR = 0x0D;
		}
		break;
	case 'v':
			if (alert_wet == 0) {
				LPUART1->TDR = 'W';
				LPUART1->TDR = 'E';
				LPUART1->TDR = 'T';
				alert_fall = 1;
				LPUART1->TDR = 0x0A;
				LPUART1->TDR = 0x0D;
			}
		break;
	}
}

void make_high(void){
	GPIOC -> ODR |= 1 << 11;
}

void make_low(void){
	GPIOC -> ODR &= ~(1 << 11);
}

void init_TIM5(){
		RCC_APB1ENR1 |= 1 << 3; //TIM6x_CLK is enabled, running at 4MHz
		TIM5->PSC = 3; //Set Prescaler
		TIM5->ARR = 1;  //Set Delay
	    TIM5->CR1 &= ~(1<<1); //OVF will generate an event
	  	TIM5->CR1 |= 1; //TIM6_CNT is enabled (clocked)
}

void wait_nano(){
	TIM5->SR=0; //clear UIF bit
	TIM5->ARR = 1;  //Set Delay
	while ( (TIM5->SR & 1) == 0 ) ; //wait until UIF is set
}

uint32_t weight_read_bit(void) {
	return (GPIOC->IDR & (1 << 10)) >> 10;  // Assuming HX711 data pin is connected to PA3
}

void weight_read_data(void) {
	int32_t data = 0;

	//while(weight_read_bit() == 0b1);

	for (int i = 23; i >= 0; i--) {
		make_high();
		wait_nano();
		data |= (weight_read_bit() << i);
		make_low();
		wait_nano();
	}

	make_high();
	wait_nano();
	make_low();
	wait_nano();

	 if ((data & 0x800000) != 0) {
	        // Extend the sign bit to the left to create a 32-bit signed integer
		 data |= 0xFF000000;
	    }

	 weight_data_temp = data;
	 weight_data = weight_data_temp * 0.002140 - 958.7;

	 if(weight_data > 500 && weight_data < 2000){
		 send_alert('w');
	 }

	 if(weight_data < 20){
		 weight_data = 0;
		 alert_weight = 0;
	 }

}

uint8_t statef=0;

void check_gas(){
	if(gas_dig_value > 1000) {
		is_gas=1;
		send_alert('g');
		GPIOC->ODR |= 1 << 7;
	} else {
		is_gas=0;
		alert_gas = 0;
		GPIOC->ODR &= ~(1 << 7);
	}
}

void check_sound(){

	if (sound_dig_value < 3800) {
		if((open_lid_signal == 0) || (calculate_sound == 0)) {
			GPIOA->ODR |= 1 << 9;
			send_alert('s');
		}
	} else {
		GPIOA->ODR &= ~(1 << 9);
		alert_sound = 0;
	}
}

void check_fire(){

	if (flame_dig_value < 4095) {
		is_fire = 1;
		send_alert('a');
		GPIOB->ODR |= (1 << 7);
	} else {
		is_fire = 0;
		alert_fire = 0;
		GPIOB->ODR &= ~(1 << 7);
	}
}

void check_adc(int mode){


	switch (mode) {
		case 0:
			check_fire();
		break;
		case 1:
			check_sound();
		break;
		case 2:
			check_gas();
		break;
	}

}

uint32_t check_rain_drop(void)
{
    return(GPIOC -> IDR  & (1<<12));
}


int main(void)
{
	init_GPIOA();
	init_GPIOB();
	init_GPIOD();
	init_GPIOG();
	init_GPIOC();
	init_LPUART();


	//init_GPIOE();
	init_TIM2();
	init_TIM3();
	init_TIM4();
	init_TIM5();
	init_TIM6();
	init_TIM7();
	init_TIM15();
	init_TIM16();

	init_ADC();


	turn_on_red();


	__asm volatile(
	 "mov r0, #0 \n\t"
	 "msr primask, r0 \n\t"
	);
    /* Loop forever */
	int i = 0;
	while(1) {

		wait_TIM3(1);
		if(which_7s) {
			write_to_7s1((fullness / 10));
		} else {
			write_to_7s2((fullness - (fullness / 10) * 10));
		}

		check_adc(i);

    	if (is_fall == 1 || is_fire || is_gas) {
    		GPIOC->ODR |= 1 << 6;
    	} else {
    		GPIOC->ODR &= ~(1 << 6);
    	}
    	if (weight_read_bit() != 0b1){
    		weight_read_data();
    	}
		if(check_rain_drop() == 0){
			turn_on_blue();
			//send_alert('v');
		}else{
			turn_off_blue();
			alert_wet = 0;
		}

    	i++;
    	i = i % 3;

	}
}
